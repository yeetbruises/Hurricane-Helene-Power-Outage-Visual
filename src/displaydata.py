"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
|                                                                      |
|  Date: 10/05/2024                             Author: Vineet Saraf   |
|  ----------------                             --------------------   |
|  File:                                                               |
|  displaydata.py - This file takes the csv generated by grabdata.py   |
|                   and matches each column name (county name) to a    |
|                   corresponding entry in the US counties shapefile.  | 
|                   A connection between the two is facilitated by     |
|                   converting names into FIPS codes retrieved from    |
|                   county-fips.csv. The animation is done by doing    |
|                   this for each row of the power outage CSV.         |
|                                                                      |
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

import geopandas as gpd
import matplotlib.pyplot as plt
import pandas as pd
import random
from matplotlib.animation import FuncAnimation
import time
import datetime
from shapely.geometry import box

from mpl_toolkits.axes_grid1.inset_locator import inset_axes

# Load the Shapefile
SHAPEFILE_PATH = './shapefiles/cb_2018_us_county_20m.shp' 
gdf = gpd.read_file(SHAPEFILE_PATH)

# Load the output CSV file
OUTPUT_CSV_PATH = './outagedata/outputnew.csv'
output_df = pd.read_csv(OUTPUT_CSV_PATH)

# Load the county FIPS CSV file
COUNTY_FIPS_PATH = './county-fips.csv'
county_fips_df = pd.read_csv(COUNTY_FIPS_PATH)

COUNTY_POPULATION_DATA = './uscounties.csv'
OUTPUT_SHAPEFILE_PATH = './shapefiles/output/added_color.shp'
RENDER_PATH = './render/'

# Plotting map limits for the X and Y direction
MIN_X, MAX_X = -100, -60   # Longitude limits
MIN_Y, MAX_Y = 24, 40      # Latitude limits
RES = 300
TOTAL_FRAMES = 368

current_frame = 0

# Plot the shapefile
fig, ax = plt.subplots(figsize=(9, 7.3), facecolor='lightgray')  # You can adjust the size as needed
  
# Function to get population by county name
def get_population_by_county(county_name, state):
    # Load the output CSV file
    cdf = pd.read_csv(COUNTY_POPULATION_DATA)

    # Filter the DataFrame for the given county name
    result = cdf[(cdf['county'].str.lower() == county_name.lower()) 
                 & (cdf['state_id'].str.lower() == state.lower())]  # Case-insensitive match
    
    if not result.empty:
        # Extract the population from the result
        population = result['population'].values[0]  # Get the population value
        return population
    else:
        return None

def update(frame):
    global current_frame 
    current_frame += 1

    a = time.time()
    frameu = frame + 100
    ax.clear()
    current_day = 0
    for index, row in gdf.iterrows():
        gdf.at[index, 'Color'] = 0

    # Get the first row of data (excluding the date column)
    row = output_df.iloc[frameu - 1, 1:]  # Assuming the first column is 'Date', slice from the second column onwards
    est_pop = 0
    # Iterate through the counties (which are the column headers) of my output file
    for _, pop in row.items():
        est_pop += pop

    for county, data_point in row.items():
        # Print both the county (column header) and its corresponding first data point
        # print(f"County: {county}, First data point: {data_point}")
        # Process county names
        county_parts = county.split(" ")
        county_parts = [part for part in county_parts if part.lower() != 'county']
        county_name_truncated = " ".join(county_parts[:-1])  # Get the truncated county name (without "County")
        state_abbreviation = county_parts[-1].upper()  # Get "SC"
        # Find the corresponding geoid in the county countyfips DataFrame
        county_fips_row = county_fips_df[(county_fips_df['county'].str.lower() == county_name_truncated.lower()) & 
                                        (county_fips_df['state'] == state_abbreviation)]
        
        
        # Check if the result is empty
        if county_fips_row.empty:
            #print(f"No match found for {county_name_truncated} in state {state_abbreviation}.")
            continue  # Skip to the next iteration if no match is found

        # Extract the "geoid" if it exists. County needs to be 3 digits ( 4 -> 004 )
        Geoid_from_fips = int(str(county_fips_row.iloc[0]['state_fips']) + str(county_fips_row.iloc[0]['county_fips']).zfill(3))

        # Iterate through each row of the shapefile
        if data_point == 0 or data_point==None: 
            continue
        
        gdf.loc[gdf['GEOID'] == str(Geoid_from_fips), 'Color'] = ( data_point / get_population_by_county(county_name_truncated, state_abbreviation) ) * 100

        current_day = output_df.iloc[frameu - 1]['Dates']  # Get the entire row, assuming FRAME starts at 1

        """
        for index, row in gdf.iterrows():
            geoid = row['GEOID']  # Get the GEOID of the current row

            if (int(geoid) == int(Geoid_from_fips)):
                gdf.at[index, 'Color'] = data_point"""

        # Save the updated GeoDataFrame back to a new shapefile (optional)
        gdf.to_file(OUTPUT_SHAPEFILE_PATH)

    # Crop the GeoDataFrame using the bounding box
    cropped_gdf = gdf.cx[MIN_X:MAX_X, MIN_Y:MAX_Y]

    plt.text(-76, 27, f'{current_day}', ha='center', va='center')
    plt.text(-77.7, 24.1, f'{round(est_pop/1000000, 3)}M people without power', ha='center', va='center')
    plt.text(-79.2, 23.1, 'Data covers FL, GA, SC, NC, TN, KY, WV, OH, VA, & AL', ha='center', va='center', fontdict={'family': 'Helvetica', 'size': 8, 'weight': 'bold'}) 

    plt.title("Power Outages in the Southeast US by Percentage of County", fontdict={'family': 'Helvetica', 'size': 16, 'weight': 'bold'})  # Optional: Add a title
    plt.text(-102, 21.8, 'Data:\n[1] https://simplemaps.com/data/us-counties.\n\n[2] https://data.usatoday.com/national-power-outage-map-tracker/.\n\n[3] https://github.com/hadley/data-counties/blob/master/county-fips.csv', ha='left', va='center', fontsize=8)
    ax.set_alpha(0.9)
    cropped_gdf.plot(column='Color', cmap='magma', vmin=0, vmax=100, ax=ax)

    #plt.xlabel("Longitude")  # Optional: Add x-axis label
    #plt.ylabel("Latitude")  # Optional: Add y-axis label

    #plt.axis("off")

    plt.gca().xaxis.set_ticklabels([])  # Remove x-axis tick labels
    plt.gca().yaxis.set_ticklabels([])  # Remove y-axis tick labels

    # Keep the box (axes frame)
    plt.gca().spines['top'].set_visible(True)
    plt.gca().spines['right'].set_visible(True)
    plt.gca().spines['left'].set_visible(True)
    plt.gca().spines['bottom'].set_visible(True)

    # FRAME += 1
    plt.savefig(f'{RENDER_PATH}my_plot{frame}.png', dpi=RES, bbox_inches='tight')
    b = time.time()
    print(f"rendering image, time taken {b-a}")
    print(f"est time left = {round( ((b-a) * TOTAL_FRAMES-current_frame) / 3600, 2)} hours")

sm = plt.cm.ScalarMappable(cmap='magma', norm=plt.Normalize(vmin=0, vmax=100))
sm._A = []  # Dummy array for colorbar

# Create a horizontal colorbar and make it smaller
cbar = plt.colorbar(sm, orientation='vertical', pad=-0.08, shrink=0.4, fraction=0.04)  # Vertical colorbar
#cbar.set_label("Percentage of County")  # Optional: add label to the colorbar

ani = FuncAnimation(fig, update, frames=TOTAL_FRAMES, interval=50)

plt.show()